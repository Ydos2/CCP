%{
    #include <stdio.h>
    #include <stdlib.h>
    #define YYDEBUG 1

    // ME ////////////////////////////////
    #include <iostream>
    using namespace std;

    extern int yyparse();
    extern FILE *yyin;
    extern int line_num;
    //////////////////////////////////////

    int yylex(void);
    void yyerror(const char *);
%}

%union {
  bool bval;
  int ival;
  char cval;
  char *sval;
}

// define the constant-string tokens:
%token PROCEDURE VAR RETURN IF ELSE WHILE _NULL_
%token INTPTR CHARPTR AND EQUAL EQUALMORE EQUALLESS DIFF OR

// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:
%token <bval> BOOLEAN
%token <ival> INTEGER
%token <cval> CHAR
%token <sval> STRING

/* Enables verbose error messages */
/* %error-verbose WITHOUT WARNING */
%define parse.error verbose

/** WRITE ME:
 *  - Put all your token definitions here
 *  - Put all your type definitions here
 *  - Put all your precedence/associativity rules here
 */

%%
// the first rule defined is the highest-level rule, which in our
// case is just the concept of a whole "csimple file":
start:
    header {
        cout << "done with a precedure file!" << endl;
    }
    ;
// CHANGE interger to all other types
header:
    header PROCEDURE STRING '(' func_param ')' RETURN types '{' func_body '}'
    | PROCEDURE STRING '(' func_param ')' RETURN types '{' func_body '}'
    | PROCEDURE STRING '(' ')' RETURN types '{' func_body '}'
    | PROCEDURE STRING '(' func_param ')' RETURN types '{' func_body '}' header
    ;

func_param:
    { cout << "Param N/A" << endl; }
    | list_func_param ':' types { cout << "Param Decla -> BON" << endl; }
    | func_param ';' list_func_param ':' types { cout << "Param Decla -> Multiple" << endl;}
    ;
list_func_param:
    list_func_param ',' STRING
    | list_func_param ',' CHAR
    | STRING
    | CHAR
    ;

func_body: expression {  }
    |
    ;
expression: types { cout << "types" << endl; }
    | PROCEDURE STRING '(' func_param ')' RETURN types '{' func_body '}'  { cout << "OTHER FUNCTION" << endl; }

    | keywords types  { cout << "keywords" << endl; }
    | operator types  { cout << "operator" << endl; }
    | expression types  { cout << "types" << endl; }

    | expression keywords types  { cout << "keywords" << endl; }
    | expression keywords  { cout << "keywords" << endl; }
    
    | expression operator types  { cout << "operator" << endl; }
    | expression operator paranthesis  { cout << "operator" << endl; }
    | expression operator '-'  { cout << "operator" << endl; }
    | expression ':' types  { cout << ":" << endl; }
    | expression ',' types  { cout << "," << endl; }
    | expression '|' types  { cout << "|" << endl; }

    | expression paranthesis types  { cout << "(" << endl; }
    | expression paranthesis operator  { cout << "(" << endl; }
    | expression paranthesis keywords  { cout << "(" << endl; }
    | expression paranthesis paranthesis  { cout << ")" << endl; }
    | expression paranthesis '-'  { cout << ")" << endl; }
    | expression ')' '{'  { cout << ")" << endl; }
    | expression ']' ';'  { cout << "]" << endl; }
    | expression ')' ';'  { cout << ")" << endl; }

    | expression ';' types { cout << ";" << endl; }
    | expression ';'  { cout << ";" << endl; }
    | keywords {  }
    | paranthesis {  }
    ;

keywords : IF '(' expression ')' '{' expression '}'
    | IF '(' expression ')' '{' expression '}' ELSE '{' expression '}'
    | WHILE '(' expression ')' '{' expression '}'
    | VAR
    | RETURN
    | _NULL_
    ;

types : STRING
    | INTEGER
    | BOOLEAN
    | CHAR
    | INTPTR
    | CHARPTR
    ;

operator : AND
    | '/'
    | '='
    | EQUAL
    | '>'
    | EQUALMORE
    | '<'
    | EQUALLESS
    | '-'
    | '!'
    | DIFF
    | OR
    | '+'
    | '*'
    | '&'
    | '^'
    ;

paranthesis : '('
    | '['
    | ')'
    | ']'
    | '{' expression '}'
    | '{' '}'
    ;
%%

/** You shall not pass!
 *  You should not  have to do or edit anything past this.
 */

extern int yylineno;

void yyerror(const char *s)
{
    fprintf(stderr, "%s at line %d\n", s, yylineno);
    exit(1);
}
